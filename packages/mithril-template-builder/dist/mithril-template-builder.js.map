{"version":3,"file":"mithril-template-builder.js","sources":["../src/index.js"],"sourcesContent":["\nconst ENTITY_REGEX = /(&#?\\w+;)/;\n\nconst svgCaseSensitiveTagNames = [\"altGlyph\", \"altGlyphDef\", \"altGlyphItem\", \"animateColor\", \"animateMotion\", \"animateTransform\", \"clipPath\", \"feBlend\", \"feColorMatrix\", \"feComponentTransfer\", \"feComposite\", \"feConvolveMatrix\", \"feDiffuseLighting\", \"feDisplacementMap\", \"feDistantLight\", \"feFlood\", \"feFuncA\", \"feFuncB\", \"feFuncG\", \"feFuncR\", \"feGaussianBlur\", \"feImage\", \"feMerge\", \"feMergeNode\", \"feMorphology\", \"feOffset\", \"fePointLight\", \"feSpecularLighting\", \"feSpotLight\", \"feTile\", \"feTurbulence\", \"foreignObject\", \"glyphRef\", \"linearGradient\", \"radialGradient\", \"textPath\"];\n\nconst svgCaseSensitiveTagNamesMap = {};\nsvgCaseSensitiveTagNames.forEach((term) => {\n  svgCaseSensitiveTagNamesMap[term.toLowerCase()] = term;\n});\n\nfunction each(list, f) {\n  for (let i = 0; i < list.length; i++) {\n    f(list[i], i);\n  }\n}\n\nfunction createFragment(markup) {\n  // escape HTML entities, to be resolved in addVirtualString\n  markup = markup.replace(/&/g, \"&amp;\");\n  if (markup.indexOf(\"<!doctype\") >= 0) {\n    return [\n      new DOMParser()\n        .parseFromString(markup, \"text/html\")\n        .childNodes[1]\n    ];\n  }\n  const container = document.createElement(\"div\");\n  container.insertAdjacentHTML(\"beforeend\", markup);\n  return container.childNodes;\n}\n\nfunction createVirtual(fragment) {\n  const list = [];\n\n  each(fragment, function(el) {\n    if (el.nodeType === 3) {\n      list.push(el.nodeValue);\n    } else if (el.nodeType === 1) {\n      const attrs = {};\n      each(el.attributes, function(attr) {\n        attrs[attr.name] = attr.value;\n      });\n\n      const tag = el.nodeName.toLowerCase();\n      const caseTag = svgCaseSensitiveTagNamesMap[tag] ? svgCaseSensitiveTagNamesMap[tag] : tag;\n\n      list.push({\n        tag: caseTag,\n        attrs,\n        children: createVirtual(el.childNodes)\n      });\n    }\n  });\n  return list;\n}\n\nfunction TemplateBuilder(virtual) {\n  this.virtual = virtual;\n  this.children = []; // each child is an object with attributes: node, children, content\n}\n\nTemplateBuilder.prototype = {\n  addVirtualString: function(el) {\n    const content = el.replace(/([\"\\r\\n])/g, \"\\\\$1\");\n    // handle HTML entities\n    const contentWithEntities = content.split(ENTITY_REGEX);\n    if (contentWithEntities.length > 1) {\n      contentWithEntities.forEach((part) => {\n        if (part.match(ENTITY_REGEX)) {\n          this.children.push({\n            content: `m.trust(\"${part}\")`\n          });\n        } else if (part) {\n          this.children.push({\n            content: `\"${part}\"`\n          });\n        }\n      });\n    } else {\n      this.children.push({\n        content: `\"${content}\"`\n      });\n    }\n  },\n\n  addVirtualAttrs: function(el) {\n    let virtual = el.tag === \"div\" ? \"\" : el.tag;\n\n    if (el.attrs.class) {\n      let attrs = el.attrs.class.replace(/\\s+/g, \".\");\n      virtual += `.${attrs}`;\n      el.attrs.class = undefined;\n    }\n\n    each(Object.keys(el.attrs).sort(), function(attrName) {\n      if (attrName === \"style\") return;\n      if (el.attrs[attrName] === undefined) return;\n      let attrs = el.attrs[attrName];\n      attrs = attrs.replace(/[\\n\\r\\t]/g, \" \");\n      attrs = attrs.replace(/\\s+/g, \" \"); // clean up redundant spaces we just created\n      attrs = attrs.replace(/'/g, \"\\\\'\"); // escape quotes\n      virtual += `[${attrName}='${attrs}']`;\n    });\n\n    if (virtual === \"\") virtual = \"div\";\n    virtual = `\"${virtual}\"`; // add quotes\n\n    if (el.attrs.style) {\n      let attrs = el.attrs.style.replace(/(^.*);\\s*$/, \"$1\"); // trim trailing semi-colon\n      attrs = attrs.replace(/[\\n\\r]/g, \"\"); // remove newlines\n      attrs = attrs.split(/\\s*;\\s*/); // [\"color:#f00\", \"border: 1px solid red\"]\n      attrs = attrs.map((propValue) => {\n        // \"color:#f00\"\n        return propValue.split(/\\s*:\\s*/).map((part) => {\n          return `\"${part}\"`;\n        }).join(\": \"); // \"\\\"color\\\": \\\"#f00\\\"\"\n      });\n      attrs = attrs.join(\", \");\n      virtual += `, {style: {${attrs}}}`;\n    }\n\n    const children = (el.children.length !== 0) ?\n      new TemplateBuilder(el.children).complete() :\n      null;\n\n    this.children.push({\n      node: virtual,\n      children\n    });\n  },\n\n  complete: function() {\n    each(this.virtual, function(el) {\n      if (typeof el === \"string\") {\n        const trimmed = el.trim();\n        const charCode = trimmed.charCodeAt();\n        // dimiss:\n        // - empty strings\n        // - single escaped quotes\n        // - single newlines\n        // - characters with char code lower than SPACE, but allow newlines in multiline text\n        if (\n          trimmed.length !== 0\n          && trimmed !== \"\\\"\"\n          && !(trimmed.length === 1 && charCode === 10)\n          && (charCode === 10 || charCode >= 32)\n        ) {\n          this.addVirtualString(trimmed);\n        }\n      } else {\n        this.addVirtualAttrs(el);\n      }\n    }.bind(this));\n    return this.children;\n  }\n};\n\nconst whitespace = (level, indent) => {\n  if (level < 0) return \"\";\n  let whitespace = \"\";\n  for (var i = 0; i < level; i++) {\n    whitespace += indent;\n  }\n  return whitespace;\n};\n\nconst wrapperTemplate = content => (\n  `[${content}\\n]`\n);\n\nconst contentTemplate = (content, whitespace) => (\n  `\\n${whitespace}${content}`\n);\n\nconst singleMithrilNodeTemplate = (mithrilNode, children, whitespace) => (\n  `\\n${whitespace}m(${mithrilNode})`\n);\n\nconst mithrilNodeMultipleChildrenTemplate = (mithrilNode, children, whitespace, indent) => (\n  `\\n${whitespace}m(${mithrilNode},\n${whitespace}${indent}[${children}\n${whitespace}${indent}]\n${whitespace})`\n);\n\nconst mithrilNodeSingleChildTemplate = (mithrilNode, child, whitespace) => (\n  `\\n${whitespace}m(${mithrilNode}, ${child}\n${whitespace})`\n);\n\nconst template = (mithrilNode, children, whitespace, indent) => (\n  children\n    ? children.length > 1\n      ? mithrilNodeMultipleChildrenTemplate(mithrilNode, children, whitespace, indent)\n      : mithrilNodeSingleChildTemplate(mithrilNode, children, whitespace, indent)\n    : singleMithrilNodeTemplate(mithrilNode, children, whitespace, indent)\n);\n\nconst formatCode = (data, level, indent) => {\n  if (!data) {\n    return \"\";\n  }\n  return data.map((d) => {\n    const space = whitespace(level, indent);\n    if (d.content) {\n      return contentTemplate(d.content, space);\n    }\n    const node = d.node || \"\";\n    const newLevel = level + (d.children && d.children.length > 1 ? 2 : 1);\n    const children = formatCode(d.children, newLevel, indent) || \"\";\n    return template(node, children, space, indent);\n  });\n};\n\nconst indentCharsMap = {\n  \"2\": \"  \",\n  \"4\": \"    \",\n  \"tab\": \"\\t\"\n};\n\n/*\nopts: {\n  source: string containing HTML markup\n  indent: either \"2\", \"4\" or \"tab\"\n}\n*/\nexport const templateBuilder = opts => {\n  const source = createVirtual(createFragment(opts.source));\n  const parsed = new TemplateBuilder(source).complete();\n  const indentLevel = parsed.length > 1 ?\n    1 :\n    0;\n  const indentChars = indentCharsMap[opts.indent || \"4\"];\n  const formatted = formatCode(parsed, indentLevel, indentChars);\n\n  // only wrap output in brackets when it is a list\n  const wrapped = formatted.length > 1 ?\n    wrapperTemplate(formatted.join(\", \")) :\n    formatted.join(\"\").trim();\n  return wrapped;\n};\n"],"names":["ENTITY_REGEX","svgCaseSensitiveTagNamesMap","each","list","f","i","length","TemplateBuilder","virtual","children","forEach","term","toLowerCase","prototype","addVirtualString","el","content","replace","contentWithEntities","split","part","match","_this","push","addVirtualAttrs","tag","attrs","class","undefined","Object","keys","sort","attrName","style","map","propValue","join","complete","node","this","trimmed","trim","charCode","charCodeAt","bind","indentCharsMap","opts","parsed","createVirtual","fragment","nodeType","nodeValue","attributes","attr","name","value","nodeName","caseTag","childNodes","markup","indexOf","DOMParser","parseFromString","container","document","createElement","insertAdjacentHTML","createFragment","source","formatted","formatCode","data","level","indent","d","space","whitespace","contentTemplate","newLevel","mithrilNode","mithrilNodeMultipleChildrenTemplate","child","mithrilNodeSingleChildTemplate","singleMithrilNodeTemplate","template"],"mappings":"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"}